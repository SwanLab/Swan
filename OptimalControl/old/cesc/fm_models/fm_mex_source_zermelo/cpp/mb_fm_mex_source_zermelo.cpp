//
// Academic License - for use in teaching, academic research, and meeting
// course requirements at degree granting institutions only.  Not for
// government, commercial, or other organizational use.
//
// mb_fm_mex_source_zermelo.cpp
//
// Code generation for function 'mb_fm_mex_source_zermelo'
//

// Include files
#include "mb_fm_mex_source_zermelo.h"
#include <cmath>

// Function Definitions
void mb_fm_mex_source_zermelo(const double states[2], double controls,
                              double statesdot[2], double j_statesdot[6])
{
  static const signed char iv[3]{0, 0, 1};
  double b_j_states[9];
  double dv[6];
  double j_statedottmp[6];
  double out1_tmp;
  double statesdot_tmp;
  int j_states_tmp;
  signed char j_states[6];
  // mb_fm_mex_source_zermelo
  //  File automatically generated by FALCON.m
  // === Extract Data From Input ==============================================
  // === Jacobians and Hessians ===============================================
  for (int i{0}; i < 6; i++) {
    j_states[i] = 0;
  }
  j_states[0] = 1;
  j_states[1] = 0;
  j_states[2] = 0;
  j_states[3] = 1;
  // === Write Constants ======================================================
  // === Subsystem source_zermelo =============================================
  //  Defined at ?
  //  Call sys_398ef064917340965807c0c11f1a7ead_jac
  // SYS_398EF064917340965807C0C11F1A7EAD_JAC
  //     [OUT1,J_OUT1,H_OUT1] =
  //     SYS_398EF064917340965807C0C11F1A7EAD_JAC(IN1,IN2VAL1) This function was
  //     generated by the Symbolic Math Toolbox version 9.3. 27-May-2025
  //     01:35:10
  // Generated using CreateGradient
  // Input dimensions : {[2 1], [1 1]}
  // Derivative inputs: [true true]
  // DerivativeOrder  : 1
  // Output dimensions: {[2 1]}
  // Constant outputs : false
  out1_tmp = std::sin(controls);
  statesdot_tmp = std::cos(controls) * 30.0;
  statesdot[0] = states[1] / 2.0 + statesdot_tmp;
  statesdot[1] = out1_tmp * 30.0;
  //  Hessian Jacobian for sys_398ef064917340965807c0c11f1a7ead_jac
  //  Calculation of Jacobian with respect to function global input for
  //  sys_398ef064917340965807c0c11f1a7ead_jac
  dv[0] = 0.0;
  dv[1] = 0.0;
  dv[2] = 0.5;
  dv[3] = 0.0;
  dv[4] = out1_tmp * -30.0;
  dv[5] = statesdot_tmp;
  for (int i{0}; i < 3; i++) {
    j_states_tmp = i << 1;
    b_j_states[3 * i] = j_states[j_states_tmp];
    b_j_states[3 * i + 1] = j_states[j_states_tmp + 1];
    b_j_states[3 * i + 2] = iv[i];
  }
  for (int i{0}; i < 2; i++) {
    out1_tmp = dv[i + 2];
    statesdot_tmp = dv[i + 4];
    for (j_states_tmp = 0; j_states_tmp < 3; j_states_tmp++) {
      j_statedottmp[i + (j_states_tmp << 1)] =
          out1_tmp * b_j_states[3 * j_states_tmp + 1] +
          statesdot_tmp * b_j_states[3 * j_states_tmp + 2];
    }
  }
  //  Combine Variables to statesdot
  j_statesdot[0] = j_statedottmp[0];
  j_statesdot[1] = j_statedottmp[1];
  j_statesdot[2] = j_statedottmp[2];
  j_statesdot[3] = j_statedottmp[3];
  j_statesdot[4] = j_statedottmp[4];
  j_statesdot[5] = j_statedottmp[5];
}

void mb_fm_mex_source_zermelo_initialize()
{
}

void mb_fm_mex_source_zermelo_terminate()
{
}

// End of code generation (mb_fm_mex_source_zermelo.cpp)
