classdef VademecumDifferenceComputer < handle
    
    properties (Access = private)
       smoothVD 
       nonSmoothVD
       difVD     
       fileName       
       outPutPath       
    end

    methods (Access = public)
        
        function obj = VademecumDifferenceComputer(d)
            obj.init(d)
        end
        
        function compute(obj)
            obj.calculateVademecum();
            obj.plotVademecum();
        end
    end
    
    methods (Access = private)
        
        function init(obj,d)
            obj.fileName    = d.fileName;
            obj.outPutPath  = d.outPutPath;  
            obj.smoothVD    = d.smoothVD;
            obj.nonSmoothVD = d.nonSmoothVD;            
        end        
        
        function calculateVademecum(obj)
            dS = obj.smoothVD.postData;
            dN = obj.nonSmoothVD.postData;
            dD.volume     = dS.volume     - dN.volume;
            dD.Ctensor    = dS.Ctensor    - dN.Ctensor;
            dD.Ptensor    = dS.Ptensor    - dN.Ptensor;
            dD.PinvTensor = dS.PinvTensor - dN.PinvTensor;
            dD.mxV        = dS.mxV;
            dD.myV        = dS.myV;
            obj.difVD = dD;          
        end
        
        function plotVademecum(obj)
            obj.makeMxMyPlot();
            obj.makeTxiRhoPlot();            
   
        end
        
        function makeTxiRhoPlot(obj)
            dS = obj.smoothVD.postData;
            iS = obj.smoothVD.feasibleIndex;
            dN = obj.nonSmoothVD.postData;
            iN = obj.nonSmoothVD.feasibleIndex;
            
            
            mxV = dS.mxV;
            myV = dS.myV;
            for i = 1:length(mxV)
                for j = 1:length(myV)
                    txi(i,j) = mxV(i)/myV(j);
                end
            end
            
            rhoN = dN.volume(iN);
            C1 = dN.Ctensor(1,1,:,:);
            C1 = squeeze(C1);
            Cn(:,1)   = C1(iN);
            txiN = txi(iN);           
            
            
            rhoS = dS.volume(iS);
            C1 = dS.Ctensor(1,1,:,:);
            C1 = squeeze(C1);
            Cs(:,1)   = C1(iS);
            txiS = txi(iS);
           
            
            Csp(:,1)  = griddata(txiS,rhoS,Cs,txiN,rhoN);
            Cnp(:,1)  = griddata(txiN,rhoN,Cn,txiS,rhoS);
            
            dif = Cs - Cnp;
            
            x = txiN;
            y = rhoN;
            z = dif;            
            hold on
            plot(x,y,'+');
            xlabel('$\frac{m1}{m2}$','Interpreter','latex');
            ylabel('\rho');      
            plot(txiS,rhoS,'+')
            
            ind = ~isnan(z);
            ncolors = 50;
            tri = delaunay(x(ind),y(ind));
            tricontour(tri,x(ind),y(ind),z(ind),ncolors)         
            
        end
        
        function computeDiference(obj,dN,dS)
            
        end
        
        function makeMxMyPlot(obj)
            d = obj.difVD;
            d.C          = obj.difVD.Ctensor;
            d.invP       = obj.difVD.PinvTensor;
            d.volume     = obj.difVD.volume;
            d.microName  = obj.fileName;
            d.outPutPath = obj.outPutPath;             
            d.hasToPrint = true;            
            p = VademecumMxMyPlotter(d);
            p.plot();               
        end
        
    end
    
    
end