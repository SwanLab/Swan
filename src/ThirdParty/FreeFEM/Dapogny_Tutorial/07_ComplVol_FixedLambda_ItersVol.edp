/* 07. Shape optimization via the Level Set method - Multiple iters geom constr */
load "medit"
load "distance"
load "iovtk"

/* Create mesh */
real fac = 1.0;
border left(t=0.0,1.5){ x=-1.0; y=1.5-t; label=0; };
border botgl(t=0.0,0.1){ x=-1.0+t; y=0.0; label=1; };
border botf1(t=0.1,0.95){ x=-1.0+t; y=0.0; label=0; };
border botneu(t=0.95,1.05){ x=-1.0+t; y=0.0; label=3; };
border botf2(t=1.05,1.9){ x=-1.0+t; y=0.0; label=0; };
border botdir(t=1.9,2.0){ x=-1.0+t; y=0.0; label=2; };
border right(t=0.0,1.5){ x=1.0; y=t; label=0; };
border top(t=0.0,2.0){ x=1.0-t; y=1.5; label=0; };
mesh Th = buildmesh(left(50*fac)+botgl(5*fac)+botf1(45*fac)+botneu(5*fac)+botf2(45*fac)+botdir(5*fac)+right(50*fac)+top(100*fac));

/* Finite Element spaces */
fespace Vh(Th,P1);
fespace Vh0(Th,P0);
include "tools.idp"


/* Initialization of the Level Set function */
Vh phik, phik1, phikj, phikj1;
phik = inils();
distance(Th,phik,phik1[]);

/* State problem */
Vh ux, uy, vx, vy;
Vh0 Achi;
real mu = 0.3846;   // Lam√© coefficients
real lambda = 0.5769;
real gx = 0.0;  // Load
real gy = -1.0;
problem elasticity([ux,uy],[vx,vy]) = int2d(Th)(Achi*mu*(2.0*dx(ux)*dx(vx) + (dx(uy)+dy(ux))*(dx(vy)+dy(vx))
                                          + 2.0*dy(uy)*dy(vy)) + Achi*lambda*(dx(ux)+dy(uy))*(dx(vx)+dy(vy)) )
                           - int1d(Th,3)(gx*vx+gy*vy)
                           + on(1,uy=0.0)
                           + on(2,ux=0.0,uy=0.0);

/* Initialization */
real ers = 1.e-3;   // Ersatz material parameter
Achi[] = volfrac(Th,phik1[],ers);
elasticity;

/* Regularization of shape derivative */
real meshsiz = 1.5/(50*fac);
real alpha = 4.0*meshsiz;
Vh g, v, g0, g0C, g0V;
problem velext(g,v) = int2d(Th)(alpha^2*(dx(g)*dx(v)+dy(g)*dy(v)) + g*v)
                      - int1d(Th,levelset=phik1)(g0*v);

/* Objective function */
macro J() (int2d(Th)(Achi*mu*(2.0*dx(ux)*dx(ux) + (dx(uy)+dy(ux))*(dx(uy)+dy(ux))
                      + 2.0*dy(uy)*dy(uy)) + Achi*lambda*(dx(ux)+dy(uy))*(dx(ux)+dy(uy)))) // EOM
/* Constraint */
macro C() (int2d(Th)(Achi)) // EOM

/* Initial value of the objective function */
real vol, Jk1, ell = 0.2, Ck;
Ck = J;
Jk1 = Ck + ell*C;
string sout;

/* Print initial objective and save initial level set function and density */
cout<<"Initial value of the objective function: "<<Jk1<<endl;

/* (Negative) shape gradient */
macro dJC() {
  g0C = mu*(2.0*dx(ux)*dx(ux) + (dx(uy)+dy(ux))*(dx(uy)+dy(ux)) + 2.0*dy(uy)*dy(uy))
       + lambda*(dx(ux)+dy(uy))*(dx(ux)+dy(uy));
} // EOM

macro dJV() {
  g0V = -ell;
} // EOM

macro dJ() {
  g0 = g0C + g0V;
  velext;
} // EOM

/* Main loop */
Vh nx,ny;
real nt = Th.nt;
real eps = 1.e-6;  // To avoid divisions by 0
real alphanor = 0.0001;   // Parameter for normal extension
real Jk, Jkj, Jkj1;
real step;
real gmax;
real tol = 0.005;   // Tolerance for accepting steps that slightly increase the objective
real tk = 1.0;   // Parameters for line search
real gk = 3.0;
real maxtk = 1.0;
real mintk = 0.1;
real maxgk = 3.0;
real mingk = 0.1;
Vh X;
int maxit = 20, kmax = 10;
int j, jmax = 1;
real[int] costPlot, volumePlot;
for (int it=0; it<maxit; it++) {
  Jk = Jk1;
  phik = phik1;
  phikj = phik1;
  Jkj = Jk1;
  X=(phik>0);
  plot(X, fill=1, value=1);
  /* Decrease tolerance after a few iterations have been made */
  if ( it == 100 ) tol = 0.001;

  /* Calculation of the shape gradient */
  dJC;
  dJV;
  dJ;
      
  gmax = max(g[].max,-g[].min);
  normalvec(phikj);
  nx = g*nx;
  ny = g*ny;

  int j = 0;
  while (j<jmax) {
    step = gk*meshsiz / (eps^2+gmax);
    phikj1[] = advectRedist(phikj[],nx[],ny[],step);
    phikj1[] = symmshape(phikj1[]);

    Achi[] = volfrac(Th,phikj1[],ers);
    Jkj1 = Ck + ell*C;
    if ( Jkj1 < Jkj + tol*abs(Jkj) || gk <= mingk ) {
      gk = min(1.1*gk,maxgk);
      j = j+1;
      dJV;
      dJ;

      gmax = max(g[].max,-g[].min);
      normalvec(phikj);
      nx = g*nx;
      ny = g*ny;

      phikj = phikj1;
      Jkj = Jkj1;
    }
    else {
      gk = max(0.6*gk,mingk);
    }
  }

  for (int k=0; k<kmax; k++) {
    phik1 = phik + tk*(phikj1 - phik);
    Achi[] = volfrac(Th,phik1[],ers);
    elasticity;
    Ck = J;
    Jk1 = Ck + ell*C;
    if ( Jk1 < Jk + tol*abs(Jk) || tk <= mintk ) {
      tk = min(1.1*tk,maxtk);
      costPlot.resize(costPlot.n+1);
      costPlot[costPlot.n-1] = J;
      volumePlot.resize(volumePlot.n+1);
      volumePlot[volumePlot.n-1] = vol;
      break;
    }
    else {
      tk = max(0.6*tk,mintk);
    }
  }

  cout<<"Iteration "<<it<<" Objective : "<<Jk1<<endl;
}
plot(X, fill=1, value=1, wait=1);

/* Save shape (level set) */
  sout = "07_Result.vtu";
  savevtk(sout, Th, phik1, dataname="LevelSet");

// write data file with "iteration value"
string datafile = "07_objectiveHistory.gp";
{
    ofstream fout(datafile);
    for (int i = 0; i < costPlot.n; ++i)
        fout << i << " " << costPlot[i] << endl;
}

// create gnuplot command to plot the data with logscale on y-axis
string gnuplotCmd = "gnuplot -e \"set term png size 800,600; set output '07_costPlot.png'; set title 'Objective History'; set xlabel 'Iteration'; set ylabel 'Compliance'; set logscale y; plot '" + datafile + "' with lines lw 2 title 'Objective'\"";

// execute gnuplot command
exec(gnuplotCmd);



// write data file with "iteration value"
datafile = "07_constraintHistory.gp";
{
    ofstream fout(datafile);
    for (int i = 0; i < volumePlot.n; ++i)
        fout << i << " " << volumePlot[i] << endl;
}

// create gnuplot command to plot the data with logscale on y-axis
gnuplotCmd = "gnuplot -e \"set term png size 800,600; set output '07_constraintPlot.png'; set title 'Constraint History'; set xlabel 'Iteration'; set ylabel 'Volume'; set logscale y; plot '" + datafile + "' with lines lw 2 title 'Objective'\"";

// execute gnuplot command
exec(gnuplotCmd);