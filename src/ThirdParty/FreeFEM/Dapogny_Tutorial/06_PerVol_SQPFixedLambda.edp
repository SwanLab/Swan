/* 06. Perimeter minimization s.t volume with a fixed multiplier and using SQP */
load "medit"
load "distance"
load "iovtk"
load "mmg"

/* Create background mesh */
real fac = 3.0;
border left(t=0.0,1.0){ x=-1.0; y=1.0-t; label=0; };
border bot(t=0.0,2.0){ x=-1.0+t; y=0.0; label=0; };
border right(t=0.0,1.0){ x=1.0; y=t; label=0; };
border top(t=0.0,2.0){ x=1.0-t; y=1.0; label=0; };
mesh Th = buildmesh(left(30*fac)+bot(60*fac)+right(30*fac)+top(60*fac));

mesh Th2; /* Th mesh after remeshing it near phi=0 */
meshL ThLInt; /* Boundary phi=0 of Th2 */

/* Finite Element spaces */
fespace Vh(Th,P1);
fespace Vh0(Th,P0);
include "tools.idp"

/* Variables definition */
Vh phi, phio, /*Test function for a velocity component:*/ v;
Vh /*Velocity components:*/ gx, gy, /*Cutoff function:*/ w;
Vh0 Achi;

/* Initialization of the Level Set function */
func real initialGuess() {
  real x0 = 0, y0 = 0.5, lx = 1.5, ly = 0.4, p = 4, ls;
  ls = ((abs((x-x0)/lx)^p+abs((y-y0)/ly)^p)^(1/p)) - 0.5;
  return(ls);
}
phio = initialGuess();
phio[] = phio[]/sqrt(int2d(Th)(phio^2));
distance(Th,phio,phi[]);

/* Initialization */
real ers = 1.e-3;   // Ersatz material parameter
Achi[] = volfrac(Th,phi[],ers);

/* Regularization of shape derivative */
real meshsiz = 1/(30*fac);
real alpha = 2.0*meshsiz;

/* Perimeter function */
macro J() (int1d(Th,levelset=phi)(1)) // EOM

/* Volume constraint */
macro C() (int2d(Th)(Achi) - 0.5) // EOM

/* Initial value of the objective function */
real newobj, ell, constr;
ell = 15; // Fixed Lagrange multiplier
constr = C;
newobj = J + 0.5*ell*constr^2;

/* Print initial objective and save initial level set function and density */
cout<<"Initial value of the objective function: "<<newobj<<endl;

int [int] lsLabel(1);
lsLabel[0] = 10;

macro updateBoundary() {
  Th2 = mmg2d(Th, iso = 1, ls = 0.0, metric = phi[], hmax = 0.05);
  Th2 = trunc(Th2, region == 3);
  ThLInt = extract(Th2,label = lsLabel);
  /*plot(ThLInt, wait=true);*/
} //

macro tanGrad(f,nx,ny) [-ny*dx(f) + nx*dy(f)] //
/* macro dHdn(nx,ny) (nx * dx(kappa) + ny * dy(kappa)) // */

varf Lr(unused,v0) = int1d(ThLInt)(sqrt(ell)*v0);

macro curvature1D() {
  kappa = dx(nx)+dy(ny);
} // EOM   

string sout;

macro dJ() {
  updateBoundary;
  
  fespace Vh1D(ThLInt,P1);
  Vh1D /*Velocity magnitude*/ g0;
  Vh1D v0, nx, ny, gx0 = dx(phi), gy0 = dy(phi);

  fespace Vh1D0(ThLInt,P0);
  Vh1D0 kappa;

  varf KM(g0,v0) = int1d(ThLInt)(tanGrad(g0,nx,ny)*tanGrad(v0,nx,ny) + g0*v0*(ell*abs(constr)*kappa));

  varf F(g0,v0) = int1d(ThLInt)(v0*(-kappa-ell*constr));

  problem projNx(nx,v0) = int1d(ThLInt)(alpha^2*(dx(nx)*dx(v0)+dy(nx)*dy(v0)) + nx*v0) 
                          - int1d(ThLInt)(Tl.y*v0);

  problem projNy(ny,v0) = int1d(ThLInt)(alpha^2*(dx(ny)*dx(v0)+dy(ny)*dy(v0)) + ny*v0) 
                            - int1d(ThLInt)(-Tl.x*v0);

  problem velextx(gx,v) = int2d(Th)(alpha^2*(dx(gx)*dx(v)+dy(gx)*dy(v)) + gx*v)
                      - int2d(Th)(g0*nx*w*v);

  problem velexty(gy,v) = int2d(Th)(alpha^2*(dx(gy)*dx(v)+dy(gy)*dy(v)) + gy*v)
                      - int2d(Th)(g0*ny*w*v);

  projNx;
  projNy;
  nx = nx/sqrt(nx^2+ny^2+1e-6);
  ny = ny/sqrt(nx^2+ny^2+1e-6);
  Vh1D sgn = nx*gx0 + ny*gy0;

for (int i = 0; i < Vh1D.ndof; ++i) {
    if (sgn[][i] < 0) {
        nx[][i] = -nx[][i];
        ny[][i] = -ny[][i];
    }
}

  curvature1D;


  constr = C;
 
  real[int] b(Vh1D.ndof);
  b = Lr(0,Vh1D);

  matrix lhs1 = KM(Vh1D,Vh1D);

  real[int] rhs = F(0,Vh1D);
  
  real[int] y1 = lhs1^-1 * rhs;

  real[int] z1 = lhs1^-1 * b;

  real den = 1.0 + b' * z1;

  g0[] = y1 - ( (b' * y1) / den ) * z1; /* Shermanâ€“Morrison formula */

normPlot.resize(normPlot.n+1);
normPlot[normPlot.n-1] = max(rhs.max,-rhs.min);

real kappaAv = int1d(ThLInt)(kappa)/int1d(ThLInt)(1);
kappaPlot.resize(kappaPlot.n+1);
kappaPlot[kappaPlot.n-1] = kappaAv;

w = exp(- (phi/(3.0*alpha))^2 );

velextx;
velexty;
Vh gNorm = sqrt(gx^2+gy^2);
real g0Max = max(g0[].max,-g0[].min);
real gMax  = gNorm[].max;
gx = gx*(g0Max/gMax);
gy = gy*(g0Max/gMax);
savevtk("VelocityX.vtu", Th, gx, dataname="vx");

Vh1D g0TM, g0M, gM;
g0TM = abs(-kappa-ell*constr);
g0M = abs(g0);
gM = sqrt(gx^2+gy^2);

real g0TeoAv = int1d(ThLInt)(-kappa-ell*constr)/int1d(ThLInt)(1);
g1Plot.resize(g1Plot.n+1);
g1Plot[g1Plot.n-1] = g0TM[].max;

real g0Av = int1d(ThLInt)(g0)/int1d(ThLInt)(1);
g2Plot.resize(g2Plot.n+1);
g2Plot[g2Plot.n-1] = g0M[].max;

real gAv = int2d(Th)(sqrt(gx^2+gy^2))/int2d(Th)(1);
g3Plot.resize(g3Plot.n+1);
g3Plot[g3Plot.n-1] = gM[].max;
} // EOM

/* Main loop */
real nt = Th.nt;
real alphanor = 0.0001;   // Parameter for normal extension
real obj;
real tol = 0.005;   // Tolerance for accepting steps that slightly increase the objective
real step = 1.0;   // Parameters for line search
real maxstep = 1.0;
real minstep = 1.0;
Vh X;
int maxit = 18, kmax = 10;
real[int] costPlot, volumePlot, normPlot, kappaPlot, g1Plot, g2Plot, g3Plot;
costPlot.resize(costPlot.n+1);
costPlot[costPlot.n-1] = newobj;
volumePlot.resize(volumePlot.n+1);
volumePlot[volumePlot.n-1] = constr;
for (int it=0; it<maxit; it++) {
  obj = newobj;
  phio = phi;
  X=(phio>0);
  plot(X, fill=1, value=1);
  /* Decrease tolerance after a few iterations have been made */
  if ( it == 100 ) tol = 0.001;

  /* Calculation of the shape gradient */
  dJ;

  /* Line search */
  for (int k=0; k<kmax; k++) {
    /* Update of the shape */
    phi[] = advectRedist(phio[],gx[],gy[],step);

    /* Calculation of the new objective function */
    Achi[] = volfrac(Th,phi[],ers);
    constr = C;
    newobj = J + 0.5*ell*constr^2;

    /* Decision */
    /* Accept iteration */
    if ( newobj < obj + tol*abs(obj) || step <= minstep ) {
      step = min(2*step,maxstep);
      costPlot.resize(costPlot.n+1);
      costPlot[costPlot.n-1] = newobj;
      volumePlot.resize(volumePlot.n+1);
      volumePlot[volumePlot.n-1] = constr;
      break;
    }
    /* Reject iteration */
    else {
      step = max(0.1*step,minstep);
      phi = phio;
      newobj = obj;
    }
  }

  cout<<"Iteration "<<it<<" Objective : "<<newobj<<endl;
}
plot(X, fill=1, value=1, wait=1);

/* Save shape (level set) */
  sout = "06_Result.vtu";
  savevtk(sout, Th, phi, dataname="LevelSet");

// write data file with "iteration value"
string datafile = "06_objectiveHistory.gp";
{
    ofstream fout(datafile);
    for (int i = 0; i < costPlot.n; ++i)
        fout << i << " " << costPlot[i] << endl;
}

// create gnuplot command to plot the data with logscale on y-axis
string gnuplotCmd = "gnuplot -e \"set term png size 800,600; set output '06_costPlot.png'; set title 'Objective History'; set xlabel 'Iteration'; set ylabel 'Perimeter'; plot '" + datafile + "' with lines lw 2 title 'Objective'\"";

// execute gnuplot command
exec(gnuplotCmd);



// write data file with "iteration value"
datafile = "06_constraintHistory.gp";
{
    ofstream fout(datafile);
    for (int i = 0; i < volumePlot.n; ++i)
        fout << i << " " << volumePlot[i] << endl;
}

// create gnuplot command to plot the data with logscale on y-axis
gnuplotCmd = "gnuplot -e \"set term png size 800,600; set output '06_constraintPlot.png'; set title 'Constraint History'; set xlabel 'Iteration'; set ylabel 'Volume'; plot '" + datafile + "' with lines lw 2 title 'Objective'\"";

// execute gnuplot command
exec(gnuplotCmd);



// write data file with "iteration value"
datafile = "06_rhsNorm.gp";
{
    ofstream fout(datafile);
    for (int i = 0; i < normPlot.n; ++i)
        fout << i << " " << normPlot[i] << endl;
}

// create gnuplot command to plot the data with logscale on y-axis
gnuplotCmd = "gnuplot -e \"set term png size 800,600; set output '06_normPlot.png'; set title 'RHS Norm History'; set xlabel 'Iteration'; set ylabel 'RHS Norm'; plot '" + datafile + "' with lines lw 2 title 'Objective'\"";

// execute gnuplot command
exec(gnuplotCmd);






// write data file with "iteration value"
datafile = "06_kappa.gp";
{
    ofstream fout(datafile);
    for (int i = 0; i < kappaPlot.n; ++i)
        fout << i << " " << kappaPlot[i] << endl;
}

// create gnuplot command to plot the data with logscale on y-axis
gnuplotCmd = "gnuplot -e \"set term png size 800,600; set output '06_kappaPlot.png'; set title 'Mean curvature av. History'; set xlabel 'Iteration'; set ylabel 'Mean curv'; plot '" + datafile + "' with lines lw 2 title 'Objective'\"";

// execute gnuplot command
exec(gnuplotCmd);






// write data file with "iteration value"
string datafile1 = "DifferentVelocities1.gp";
{
    ofstream fout(datafile1);
    for (int i = 0; i < g1Plot.n; ++i)
        fout << i << " " << g1Plot[i] << endl;
}

// write data file with "iteration value"
string datafile2 = "DifferentVelocities2.gp";
{
    ofstream fout(datafile2);
    for (int i = 0; i < g2Plot.n; ++i)
        fout << i << " " << g2Plot[i] << endl;
}

// write data file with "iteration value"
string datafile3 = "DifferentVelocities3.gp";
{
    ofstream fout(datafile3);
    for (int i = 0; i < g3Plot.n; ++i)
        fout << i << " " << g3Plot[i] << endl;
}

// create gnuplot command to plot the data with logscale on y-axis
gnuplotCmd = 
    "gnuplot -e \"set term png size 800,600; " +
    "set output 'DiffVelocities.png'; " +
    "set title 'Velocities av. History'; " +
    "set xlabel 'Iteration'; set ylabel 'Velocities'; set logscale y; " +
    "plot '" + datafile1 + "' with lines lw 2 title 'Teo', " +
    "'" + datafile2 + "' with lines lw 2 title 'New', " +
    "'" + datafile3 + "' with lines lw 2 title 'New extended'\"";
// execute gnuplot command
exec(gnuplotCmd);