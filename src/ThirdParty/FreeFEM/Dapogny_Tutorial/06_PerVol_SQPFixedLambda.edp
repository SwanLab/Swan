/* 06. Perimeter minimization s.t volume with a fixed multiplier and using SQP */
load "medit"
load "distance"
load "iovtk"

/* Create mesh */
real fac = 3.0;
border left(t=0.0,1.0){ x=-1.0; y=1.0-t; label=0; };
border bot(t=0.0,2.0){ x=-1.0+t; y=0.0; label=0; };
border right(t=0.0,1.0){ x=1.0; y=t; label=0; };
border top(t=0.0,2.0){ x=1.0-t; y=1.0; label=0; };
mesh Th = buildmesh(left(30*fac)+bot(60*fac)+right(30*fac)+top(60*fac));

mesh ThInt;
meshL ThLInt;
int[int] L(1);
L[0] = 2;

/* Finite Element spaces */
fespace Vh(Th,P1);
fespace Vh0(Th,P0);
include "tools.idp"


/* Initialization of the Level Set function */
func real initialGuess() {
  real x0 = 0, y0 = 0.5, l = 0.75, p = 4, ls;
  ls = ((abs(x-x0)^p+abs(y-y0)^p)^(1/p))/l - 0.5;
  return(ls);
}
Vh phio, phi;
phio = initialGuess();
distance(Th,phio,phi[]);

/* Initialization */
Vh0 Achi;
real ers = 1.e-3;   // Ersatz material parameter
Achi[] = volfrac(Th,phi[],ers);

/* Regularization of shape derivative */
real meshsiz = 1/(30*fac);
real alpha = 4.0*meshsiz;
Vh g, v;

fespace Vh1(ThLInt,P1);
Vh1 g0Teo, g0, v0;

problem velext(g,v) = int2d(Th)(alpha^2*(dx(g)*dx(v)+dy(g)*dy(v)) + g*v)
                      - int1d(Th,levelset=phi)(g0*v);

/* Objective function */
macro J() (int1d(Th,levelset=phi)(1)) // EOM

/* Constraint */
macro C() (int2d(Th)(Achi)) // EOM

/* Initial value of the objective function */
real newobj, ell;
ell = 20*(C-0.5); // Variable lagrange multiplier
newobj = J + ell*(C-0.5);

/* Print initial objective and save initial level set function and density */
cout<<"Initial value of the objective function: "<<newobj<<endl;

/* (Negative) shape gradient */
Vh nx, ny, vx, vy, kappa;

macro updateBoundary() {
  ThInt = trunc(Th, phi<=0);
  ThLInt = extract(ThInt, label = L);
  plot(ThLInt, wait=true);
} //

macro tanGrad(f,nx,ny) [-ny*dx(f) + nx*dy(f)] //
macro dHdn(nx,ny) (nx * dx(kappa) + ny * dy(kappa)) //
problem computeShapeDerivative(g0,v0) = int1d(ThLInt)(tanGrad(g0,nx,ny)*tanGrad(v0,nx,ny)+g0*v0*(dHdn(nx,ny)+kappa^2+ell*kappa)) 
                                          - int1d(ThLInt)(-v0*kappa-v0*ell);

/* Temporal stuff */
string datafile1 = "data1.gp";
string datafile2 = "data2.gp";
string gnuplotCmd = 
    "gnuplot -e \"set term png size 800,600; " +
    "set output 'sourceComparison2.png'; " +
    "set title 'Laplace Beltrami operator'; " +
    "set xlabel 't'; set ylabel 'Shape derivative'; " +
    "plot '" + datafile1 + "' with lines lw 2 title 'Original', " +
    "'" + datafile2 + "' with lines lw 2 title 'Smoothed'\"";

macro dJ() {
  updateBoundary;
  computeShapeDerivative;

  /* Temporal stuff */
  int NbVertices = ThLInt.nv;
  real[int] t(NbVertices);
  t[0] = 0;
  for (int i = 1; i < NbVertices; i++) {
    t[i] = t[i-1] + 3.0/(NbVertices-1);
  }
  g0Teo = -kappa - ell;
  cout<<"MIN: "<<g0Teo[].min<<" MAX: "<<g0Teo[].max<<endl;
  {
    ofstream fout(datafile1);
    for (int i = 0; i < NbVertices; ++i)
        fout << t[i]<< " " << g0Teo[][i] << endl;
  }
  {
    ofstream fout(datafile2);
    for (int i = 0; i < NbVertices; ++i)
        fout << t[i]<< " " << g0[][i] << endl;
  }
  exec(gnuplotCmd);

  velext;
} // EOM

/* Main loop */
real nt = Th.nt;
real eps = 1.e-6;  // To avoid divisions by 0
real alphanor = 0.0001;   // Parameter for normal extension
real obj;
real step;
real gmax;
real tol = 0.005;   // Tolerance for accepting steps that slightly increase the objective
real coef = 3.0;   // Parameters for line search
real maxcoef = 3.0;
real mincoef = 0.1;
Vh X;
Vh0 kappa0;
int maxit = 1, kmax = 10;
real[int] costPlot, volumePlot;
costPlot.resize(costPlot.n+1);
costPlot[costPlot.n-1] = J;
volumePlot.resize(volumePlot.n+1);
volumePlot[volumePlot.n-1] = C;
string sout;
for (int it=0; it<maxit; it++) {
  obj = newobj;
  phio = phi;
  X=(phio>0);
  plot(X, fill=1, value=1);
  /* Decrease tolerance after a few iterations have been made */
  if ( it == 100 ) tol = 0.001;

  /* Calculation of the shape gradient */
  normalvec(phi);
  curvature;
  dJ;

  sout = "ShapeGradient.vtu";
  savevtk(sout, Th, g, dataname="Gradient");


  gmax = max(g[].max,-g[].min);
  nx = g*nx;
  ny = g*ny;

  /* Line search */
  for (int k=0; k<kmax; k++) {
    /* Calculation of step: maximum amplitude of motion = meshsiz*coef */
    step = coef*meshsiz / (eps^2+gmax);

    /* Update of the shape */
    phi[] = advectRedist(phio[],nx[],ny[],step);
    phi[] = symmshape(phi[]);

    /* Calculation of the new objective function */
    Achi[] = volfrac(Th,phi[],ers);
    ell = 20*(C-0.5); // Variable lagrange multiplier
    newobj = J + ell*(C-0.5);

    /* Decision */
    /* Accept iteration */
    if ( newobj < obj + tol*abs(obj) || coef <= mincoef ) {
      coef = min(1.1*coef,maxcoef);
      costPlot.resize(costPlot.n+1);
      costPlot[costPlot.n-1] = J;
      volumePlot.resize(volumePlot.n+1);
      volumePlot[volumePlot.n-1] = C;
      break;
    }
    /* Reject iteration */
    else {
      coef = max(0.6*coef,mincoef);
      phi = phio;
      newobj = obj;
    }
  }

  cout<<"Iteration "<<it<<" Objective : "<<newobj<<endl;
}
plot(X, fill=1, value=1, wait=1);

/* Save shape (level set) */
  sout = "06_Result.vtu";
  savevtk(sout, Th, phi, dataname="LevelSet");

// write data file with "iteration value"
string datafile = "06_objectiveHistory.gp";
{
    ofstream fout(datafile);
    for (int i = 0; i < costPlot.n; ++i)
        fout << i << " " << costPlot[i] << endl;
}

// create gnuplot command to plot the data with logscale on y-axis
gnuplotCmd = "gnuplot -e \"set term png size 800,600; set output '06_costPlot.png'; set title 'Objective History'; set xlabel 'Iteration'; set ylabel 'Perimeter'; set logscale y; plot '" + datafile + "' with lines lw 2 title 'Objective'\"";

// execute gnuplot command
exec(gnuplotCmd);



// write data file with "iteration value"
datafile = "06_constraintHistory.gp";
{
    ofstream fout(datafile);
    for (int i = 0; i < volumePlot.n; ++i)
        fout << i << " " << volumePlot[i] << endl;
}

// create gnuplot command to plot the data with logscale on y-axis
gnuplotCmd = "gnuplot -e \"set term png size 800,600; set output '06_constraintPlot.png'; set title 'Constraint History'; set xlabel 'Iteration'; set ylabel 'Volume'; set logscale y; plot '" + datafile + "' with lines lw 2 title 'Objective'\"";

// execute gnuplot command
exec(gnuplotCmd);