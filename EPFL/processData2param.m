close all
clear all
% Specify the directory where the .mat files are located
directory = './EPFL/dataLattice2param'; % Update this path as needed

% Get a list of all .mat files in the directory
files = dir(fullfile(directory, 'data_*.mat'));

% Loop through each file and load it
i=1;
for k = 1:3:length(files)
    % Get the full path to the file
    filePath = fullfile(files(k).folder, files(k).name);

    % Load the file
    load(filePath);

    % Optionally, store each loaded variable into a structure or cell array
    % For example, you could store the variables in a cell array:
    T(:,i) = EIFEoper.U;  % This stores each file's contents in the cell array 'allData'
    Td(:,i) = EIFEoper.Udef(:);
    Tr(:,i) = EIFEoper.Urb(:);
    Kcoase(:,i) = EIFEoper.Kcoarse(:);
    Kfine(:,i) = EIFEoper.Kfine(:);
    PhiD(:,i) = EIFEoper.PhiD(:);
    PhiR(:,i) = EIFEoper.PhiR(:);
    U(:,i) = EIFEoper.snapshots(:);
    coord(i,:) = [EIFEoper.h1,EIFEoper.h2 ];
    % If you want to work with specific variables in each file, you can access them like:
    % data.variableName

    disp(['Loaded: ', files(k).name]);  % Display the file being loaded
    i=i+1;
end

[fT,deim,dfT]   = parameterizedDataLagrange(T,coord);
% t    = fT(xdata);
[Tdef,~,dTdef]  = parameterizedDataLagrange(Td,coord);
% def  = Tdef(xdata);
[Trb,~,dTrb]  = parameterizedDataLagrange(Tr,coord);
% rb   = Trb(xdata);
[fK,~,dfK]   = parameterizedDataLagrange(Kcoase,coord);
% Kcoarse = fK(xdata);

EIFEoper.Kcoarse = fK;
EIFEoper.Udef = Tdef;
EIFEoper.Urb  = Trb;
EIFEoper.U    = fT;
EIFEoper.dKcoarse = dfK;
EIFEoper.dUdef = dTdef;
EIFEoper.dUrb  = dTrb;
EIFEoper.dU    = dfT;

EIFEoper.deim    = deim;
filePath = './EPFL/parametrizedEIFEMLagrange_2params.mat';
save(filePath,'EIFEoper')

function [f,deim,df] = parameterizedDataLagrange(var,xdata)
deim  = DEIM(var);
coeff = deim.basis(deim.indices,:)\var(deim.indices,:);
mesh = createMesh(xdata);
bFun  = createLagrangianFunction(mesh);


y =   leastSquares(coeff,xdata,bFun);
ss.mesh  = mesh;
ss.ndimf = 1;
ss.order = 'P8';

fR = arrayfun(@(i) ...
        LagrangianFunction(setfield(ss, 'fValues', y(:,i))), ...
        1:size(y,2), ...
        'UniformOutput', false);
fR = [fR{:}];
% coeff = deim.rightVectors';

% tri = delaunay(xdata(:,1), xdata(:,2));
% for i=1:length(fR) 
%     yplot = fR(i).evaluate(2*(xdata' - min(xdata)')./ (max(xdata)' - min(xdata)') - 1)'; 
%     figure
%     % plot(xdata,yplot(:,i))
%      % trisurf(tri, xdata(:,1), xdata(:,2), yplot);
%     scatter3(xdata(:,1), xdata(:,2), yplot);
%     hold on
%      % plot(xdata,coeff(i,:))
%      trisurf(tri, xdata(:,1), xdata(:,2), coeff(i,:));
% %     yplot2(i) = bFun.evaluate(xdata(i)); 
% end
% values = arrayfun(@(fun) evaluate(fun, 2*(0.1 - min(xdata)) / (max(xdata) - min(xdata)) - 1), fR, 'UniformOutput', false);

x_min = min(xdata)';
L_dom = max(xdata)' - x_min;

scale = 2 ./ L_dom;
shift = - (2 * x_min ./ L_dom) - 1;
B = deim.basis;
numFuns = length(fR);

firstCol = @(x) x(:, 1);
nrows = size(reshape(B(:,1) , [], 8),1);

% 2. Apply it inside your function handle
%    This discards the phantom 2nd column generated by the bug
f = @(r) reshape(B * evaluateAll(fR, r.*scale + shift, numFuns), nrows, 8,[]);
% f = @(r) reshape(B * evaluateAll(fR, r.*scale + shift, numFuns), [], 8);

gR_cell = arrayfun(@(fun) Grad(fun), fR, 'UniformOutput', false);
gR = [gR_cell{:}]; 

numGrads = length(gR);
df = @(r) reshape((evaluateAllGrads(B,gR, r.* scale + shift, numGrads)), nrows, 8, mesh.ndim,[]);
end

function bFun = createLagrangianFunction(mesh)
    order = 'P8';
    ndimf = 1;
    bFun = LagrangianFunction.create(mesh,ndimf,order);
end

function mesh = createMesh(xdata)
    xmax = max(xdata(:,1)); xmin = min(xdata(:,1));
    ymax = max(xdata(:,2)); ymin = min(xdata(:,2));
    s.coord = [xmin, ymin;
               xmax  ymin;
               xmax  ymax;
               xmin  ymax;];
    s.connec = [1,2,3,4];
    mesh = Mesh.create(s);
end


function vals = evaluateAll(fR, s, n)
    numPoints = length(s);
    % vals = zeros(n, numPoints);
    for i = 1:n
        vals(i, :) = evaluate(fR(i), s);
    end
end

function grad = evaluateAllGrads(B,gR, s, n)
    % Pre-allocate matrix: [Number of Basis Functions x Number of Points]
    numPoints = length(s);
    grad = zeros(size(B(:,1),1), 2,numPoints);
    npoints = size(s,2);
    for i = 1:n
        % Direct assignment is significantly faster than cell2mat
        val =  evaluate(gR(i), s);
        gradBasis = B(:,i) .* reshape(val,1,2,npoints);
        grad = grad + gradBasis;
        % vals(:, i,:) = .* evaluate(gR(i), s);
    end
end

function y = leastSquares(data,xdata,f)
minVal = min(xdata, [], 1); 
maxVal = max(xdata, [], 1); 
scaledData = 2 * (xdata - minVal) ./ (maxVal - minVal) - 1;
    A = f.computeShapeFunctions(scaledData')';
%     y =inv(A'*A)\A'*data';  
    y = A \ data'; 
end
